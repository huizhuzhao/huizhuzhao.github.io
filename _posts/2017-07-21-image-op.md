---
layout: post
title: Image op
date: 2017-03-25
---

### opencv

* 使用 opencv 读取图片，并对生成的矩阵进行模式变换
```
src_img = './test.jpg'
array_bgr = cv2.imread(src_img)
array_rgb = cv2.cvtColor(array_bgr, cv2.COLOR_BGR2RGB)
array_gray = cv2.cvtColor(array_bgr, cv2.COLOR_BGR2GRAY)
```
* 将矩阵写到文件中
```
cv2.imwrite('./new_img.jpg', array_gray)
```
* 显示opencv 中所有图片的模式转变
```
mode_convert = [x for x in dir(cv2) if 'COLOR_' in x]
```

### PIL
* 使用 Image 读取图片，并展示

```
from PIL import Image
img_rgb = Image.open(src_img)
img_gray = Image.open(src_img).convert('L')
img_rgb.show()

```

* Image 对象与 numpy 矩阵转换
```
array_rgb = np.asarray(img_rgb, dtype=np.int32) # shape=(height, width, channel)
array_gray = np.asarray(img_gray, dtype=np.int32)
new_img_rgb = Image.fromarray(array_rgb.astype('uint8'), mode='RGB') # uint8 is necessary
new_img_gray = Image.fromarray(array_gray.astype('uint8'), mode='L')
```

* 将 Image 对象写入文件中

```
img_rgb.save('./img_rgb.jpg')
```

### maplotlib

* `fig, axes = plt.subplots(nrows, ncols, figsize=(10, 5), **kwargs)`

 **fig**: Figure对象, 表示整张图, 可通过 fig.text(x, y, string) 在图上任意位置添加注释
 
 **axes**: numpy array，其中每个元素表示不同子图的对象, axes.shape=(nrows, ncols), 
 通过 `axes[0].get_position().bounds` 返回坐标值 `(x_left, y_lower, width, height)`
 
 **kwargs**: sharex, sharey, {True, 'col', 'row', 'all'}
 

* 为图片添加 colorbar

 * prepare image arrays
```
src_face = './test.jpg'
array_bgr = cv2.imread(src_face)
array_rgb = cv2.cvtColor(array_bgr, cv2.COLOR_BGR2RGB)
array_gray = cv2.cvtColor(array_bgr, cv2.COLOR_BGR2GRAY)
```

 * plot
```
fig, axes = plt.subplots(ncols=2, figsize=(8, 3))
mappable_1 = axes[0].imshow(array_gray, cmap='Blues', interpolation='none')
mappable_2 = axes[1].imshow(array_gray, cmap='Greens', interpolation='none')
fig.colorbar(mappable_1, ax=axes[0])
fig.colorbar(mappable_2, ax=axes[1])
axes[0].axis('off')
axes[1].axis('off')
plt.show()
```
![](http://oe5p7f8mz.bkt.clouddn.com/colorbar.png)
 如果图片矩阵若为 **rgb** 类型，则 colorbar 不再生效
 
* 以 iris data 为列
  * prepare data
  ```
import pandas as pd
import matplotlib.pyplot as plt
iris_file = '/home/huizhu/bitbucket/test_data/iris/iris.csv'
df = pd.read_csv(iris_file)
x_1 = df['sepal length']
x_2 = df['sepal width']
x_3 = df['petal length']
class_dict = {'Iris-setosa': 0, 'Iris-versicolor': 1, 'Iris-virginica': 2}
Y = [class_dict[n] for n in df.values[:, 4].tolist()]
  ```
  * plot
  ```
fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 3), sharey=True)
mappable_1 = ax1.scatter(x_1, x_2, c=Y, cmap='Blues')
mappable_2 = ax2.scatter(x_3, x_2, c=Y, cmap='Blues')
ax1.set_xlabel('sepal length')
ax1.set_ylabel('sepal width')
ax2.set_xlabel('petal length')
fig.colorbar(mappable_1, ax=ax1)
fig.colorbar(mappable_2, ax=ax2)
plt.show()
  ```
  ![](http://oe5p7f8mz.bkt.clouddn.com/iris_colorbar.png)
  
* 可用的 cmaps
 ```
 # Have colormaps separated into categories:
 # http://matplotlib.org/examples/color/colormaps_reference.html
cmaps = [('Perceptually Uniform Sequential', [
            'viridis', 'plasma', 'inferno', 'magma']),
         ('Sequential', [
            'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',
            'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',
            'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn']),
         ('Sequential (2)', [
            'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink',
            'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia',
            'hot', 'afmhot', 'gist_heat', 'copper']),
         ('Diverging', [
            'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu',
            'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic']),
         ('Qualitative', [
            'Pastel1', 'Pastel2', 'Paired', 'Accent',
            'Dark2', 'Set1', 'Set2', 'Set3',
            'tab10', 'tab20', 'tab20b', 'tab20c']),
         ('Miscellaneous', [
            'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern',
            'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg', 'hsv',
            'gist_rainbow', 'rainbow', 'jet', 'nipy_spectral', 'gist_ncar'])]
 ```


```python
import numpy as np
import pandas as pd
import cv2
import PIL
from PIL import Image
import matplotlib.pyplot as plt
import glob
```

## `tf.contrib.data.Dataset`
假设我们有 N 个样本, 对应的样本 ID 为 `{0, 1, 2, ..., N-1}`。我们使用 `tensorflow.contrib.data` 中的 `Dataset` 按顺序读入的数据，随后我们每次从中获取一个 `mini_batch` (大小为 `batch_size`)的样本，共获取 `N/batch_size`个`mini_batch`。因为数据是按照由小到大的顺序读入，因此获取数据的顺序同样由小到大，如下所示：

```
batch_0: {index_0+0, index_0+1, ..., index_0+batch_size-1}, index_0 = 0
batch_1: {index_1+0, index_1+1, ..., index_1+batch_size-1}, index_1 = batch_size * 1
...
batch_i: {index_i+0, index_i+1, ..., index_i+batch_size-1}, index_i = batch_size * (i-1)
...
```
现在我们使用 `Dataset.shuffle(buffer_size)` 方法对数据进行打乱，并测试 `buffer_size` 的大小对 `shuffle` 效果的影响。

理想情况下我们希望每次获取的 `batch_size` 个样本数据在原始顺序中尽可能的混乱。因此我们

1. 计算每个 `mini_batch` 中的样本位于原始序列中的 `batch_id = ID//batch_size`
2. 并统计 `batch_id` 的种类数作为混乱度 (`diversity`) 用来衡量混乱程度

比如当 `N=100, batch_size=10`, 某次获取的一个 `mini_batch` 数据的样本 ID 为 

`ID = {12, 10, 29, 40, 19, 19, 26, 76, 56, 20}`

则对应的 `batch_id` 和 `diversity` 为 

`batch_id = {1, 1, 2, 4, 1, 1, 2, 7, 5, 2}`

`diversity = len(set(batch_id)) = 5`。

通常情况下 `N >> batch_size`，因此 `diversity` 越接近 `batch_size` 表明混乱度越高。

如下图所示，我们取`N={1000, 2000, 4000, 8000, 16000, 20000, 32000}`,  `batch_size=100`, 对于每组 `(N, batch_size)`，测试 `buffer_size={1, batch_size, 2*batch_size, ..., factor*batch_size}` 其中 `factor = N//batch_size`

![](http://obmpvqs90.bkt.clouddn.com/tf_dataset_shuffle_buffer_size_1.png)
